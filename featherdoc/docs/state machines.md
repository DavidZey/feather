#feather Finite State Machines#

Finite State Machines (FSM) are well understood in computer science, and as such I won't cover them much here.  There are some really good articles online that you can check out to read more in depth analysis on FSM's.

[Wikipedia](http://en.wikipedia.org/wiki/Finite-state_machine)

[State Machine Basics](http://blog.markwshead.com/869/state-machines-computer-science/)

In the simpliest definition a FSM is a set of states and transitions.  A FSM can only be in one state a time, thus allowing you to easily build state driven applications like Single Page Websites.  In more complex systems that utilize state machines you will begin to see hierarchical state machines, and states that have their own state machines.

In general FSM is a tool that simplifies common problems including UI management and async flow.

###Benefits of State Machines###

An application could easily be created without utilizing FSM's, but there are some clear advantages to using them.

-     `Flexibility` : Code can easily be tweaked and extended with proper use of state machines.

-     `Debugging` : Code that is isolated in small testable states makes it much easier to track down defects in code.

-     `Simplicity` : Its human nature to think of things in terms of states.  It is generally simple to break down parts of software in terms of states.

###Example FSM###

A simple 3 state FSM in feather.

    onReady: function() {
      var me = this;
      me.fsm = new feather.FiniteStateMachine({
        states: {
          initial:  {
            stateStartup: function() {
              return this.states.enabled;
            }
          },
          enabled: {
            stateStartup: function( ) {
              //Enable here
            },
            clicked: {
              return this.states.disabled;
            }
          },
          disabled: {
            stateStartup: function( ) {
              //Disable Here
            }
          }
        }
      });
    }

Let's walk through what is happening in this simple example.  The FSM is created and by default enters the initial state.  The event stateStartup is fired and a transition is generated by returning a state.  Next the FSM enters the enabled event and waits for the clicked event before transitioning to the disabled state.

A FSM is first instantiated in the fsm member variable of me so communication with the fsm can occur which I will cover below.  Then the states are declared, in this example we have a very simple 3 state FSM (initial, enabled, disabled).  Each state has two very important optional events which are stateStartup and leavingState.  In this simple example only stateStartup is utilized, but we could just as easily added leavingState.

###FSM Communication###

    me.domEvents.bind( me.get( "#foo"), "click", function( ) {
      me.fsm.fire("clicked");
    });


foo specifies a HTML element by id, that is bound to the click event.  The callback sends the "clicked" event to the state machine.

That is really it, just fire the event and the state machine will handle it if that event is implemented.  This allows modelling of complex models using a powerful design tool long understood in the computer science world.


###A Real Example###

I've contrived an example that mimics a form submission, so I've created a state machine to control this.  Lets go straight to the code, then I'll walk through some of it.

####HTML####

    <input type="text" id="tutorialTextbox" /> <br />
    <input type="checkbox" id="tutorialCheckbox" />I Agree
    <br /><br />
    <button disabled="true" id="tutorialButton">Submit</button>

####Client Side State Machine####

    var me = this;
    //
    //Form Submission Example
    var button = me.get("#tutorialButton");
    var checkbox = me.get("#tutorialCheckbox");
    var textbox = me.get("#tutorialTextbox");
     me.fsm = new feather.FiniteStateMachine( {
      states: {
        initial: {
          stateStartup: function( ) {
            return this.states.waiting;
          }
        },
        waiting: {
          stateStartup: function( ) {
            button.attr("disabled", true);
            checkbox.attr("disabled", false); 
          },
          checked: function( ) {
            return this.states.enabled;
          }
        },
        enabled: {
          stateStartup: function( ) {
            button.attr("disabled", false); 
            checkbox.attr("disabled", false);
          },
          unchecked: function( ) {
            return this.states.waiting;
          },
          click: function( ) {
            return this.states.validate;
          }
        },
        submit: {
          stateStartup: function( ) {
            var email = textbox.val();
            me.server_submitInfo([email], function (args) {
              me.fsm.fire("response", args);
            });
          },
          response: function(args) {
            return args.success ? this.states.success : this.states.error;
          }
        },
        validate: {
          stateStartup: function( ) {
            button.attr("disabled", true);
            checkbox.attr("disabled", true);
            //Super complex validation that an email is believed to be valid
            var txt = textbox.val();
            if(txt.length < 5) {
              return this.states.error;
            } else {
              return this.states.submit;
            }
          }
        },
        error: {
          stateStartup: function( ) {
            //Show some sort of error indication here
            button.attr("disabled", false);
            checkbox.attr("disabled", false);
            textbox.val("ERR");
            return this.states.enabled;
          }
        },
        success: {
          stateStartup: function( ) {
            me.get("#tutorialTextbox").val("Thank You");
          }
        }  
      }
    });

####Client Side Binding####

    //Bind Events
    me.domEvents.bind(me.get("#tutorialButton"), "click", function(args) {
      me.fsm.fire("click");
    });

    me.domEvents.bind(me.get("#tutorialCheckbox"), "click", function(args){
      this.checked ? me.fsm.fire("checked") : me.fsm.fire("unchecked");        
    });

####Server Side Validation####

    prototype: {
      submitInfo: feather.Widget.serverMethod(function(email, _cb){
        if(Math.floor(Math.random()*11)<5){
          _cb("Not Valid");
        } else {
          _cb(null);
        }
      })
    }

First off no real validation is occuring, the client checks to make sure there is a string input into the textfield and then sends it to the server, the server just randomly tells the client they failed or succeeded.

I start by defining the states.

-     initial : Required by feather as the starting state.

-     waiting : This state enables both controls, and waits until the checkbox is checked.

-     enabled :  This state waits until the button is clicked, and transitions to the validate state.

-     submit : Sends the data to the server and waits for a response.  Based on the response the state machine will either transition to error state or success state.

-     validate : Client side validation, this can be as complex as you would want it to be.

-     error : Generic error state that any error causes a transition to.

-     success : The final state once the form is validated and finished.

My next step before implementation is to define the transitions.  In more complex systems its best to layout a decision tree so its easy to see how the transitions occur, but in this case its simple enough to just write down.


I think this example state machine is easy enough to understand but I want to elaborate on a few items.  Even though this is being used primarily for UI management in this example its also very easy to see how it can be used for async flow just by seeing how the call to the server is handled in the submit state.  I simply fire an event from the callback to the state machine, and everything is handled from there.  You could easily build a state machine to better represent the async calls which keeps your code cleaner and easier to maintain.  Another place that I really appreciate state machines is being able to have one common place where error handling is done.

In this example its easy to see that each piece of functionality is separated, so extending the functionality or tracking down a defect is much easier to accomplish.  


###Useful Functions###

FSM's in feather implement the following functions

-     `gotoPreviousState` : Switches the state machine back to the previous state.

-     `gotoInitialState` :  Transitions to the Initial state in the state machine.

-     `getCurrentStateName` :  Returns the name of the current state which is mainly useful for test cases and debugging.


###Inside Feather###

The feather framework utilizes FSM's throughout, each widget is in fact derived from FiniteStateMachine.  FiniteStateMachine is derived from EventPublisher which provides the fire method.